#lang racket

(provide open-out-file)

(define (open-out-file directory xml-file folder-name)
  (define input-port (open-input-file (string-append directory "/" (path->string xml-file))))
  (define xml-file-name (substring (path->string xml-file) 0 (- (string-length (path->string xml-file)) 5)))
  (define output-port (open-output-file (string-append directory "/" xml-file-name ".xml") #:exists 'append))
  (parse input-port output-port))

(define (string-repeat str repetitions)
  (if (zero? repetitions)
      ""
      (string-append str (string-repeat str (- repetitions 1)))))

(define (parse input-port output-port)
  (define spaces 0)
  (define str-spl "")
  (define line (read-line input-port))
  (define line0 "")
  (define line1 "")

  (define (print word)
    (display (string-append (string-repeat " " spaces) word "\n") output-port)
    (display (string-append (string-repeat " " spaces) word "\n")))
  
  (define (advance)
    (set! line (read-line input-port))
    (cond 
      [(equal? line "</tokens>")]
      [(eof-object? line)]
      [(set! str-spl (string-split line ">"))
       (set! line0 (list-ref (string-split (list-ref (string-split line ">") 0) "<") 0))
       (cond
         [(> (length str-spl) 1)
          (set! line1 (list-ref (string-split (list-ref str-spl 1) "<") 0))
          (set! line1 (substring line1 1 (- (string-length line1) 1)))])]))

  (define (parse)
    (advance)
    (display "<class>\n" output-port)
    (set! spaces (+ spaces 2))
    (parse-class)
    (set! spaces (- spaces 2))
    (display "</class>\n" output-port)
    (close-input-port input-port)
    (close-output-port output-port))

  (define (parse-class)
  (print line)
  (advance)
  (print line)
  (advance)
  (print line)
  (advance)
  (define first line1)
  (cond [(equal? line1 "}") (print line) (advance)]
        [(or (equal? line1 "static") (equal? line1 "field")) (parse-class-var-dec)]
        [(or (equal? line1 "method") (equal? line1 "constructor") (equal? line1 "function"))(parse-subroutine)])
  (cond [(and (or (equal? first "static") (equal? first "field")) (or (equal? line1 "method") (equal? line1 "constructor") (equal? line1 "function"))) (parse-subroutine)])
  (cond [(not (equal? first "}")) (print line) (advance)]))

  
  (define (parse-class-var-dec)
     (print "<classVarDec>")
     (set! spaces (+ spaces 2))
    (print line)
    (advance)
    (print line)
    (advance)
    (print line)
    (advance)
    (let loop()
      (cond ((equal? line1 ",")
            (print line)
            (advance)
            (print line)
            (advance)
            (loop))
          (else (print line)
            (advance))))
    (set! spaces (- spaces 2))
    (print "</classVarDec>")

    (cond [(or (equal? line1 "static") (equal? line1 "field"))
           (parse-class-var-dec)]))

   
   (define (parse-subroutine)
     (print "<subroutineDec>")
     (set! spaces (+ spaces 2))
     (print line)
     (advance)
     (print line)
     (advance)
     (print line)
     (advance)
     (print line)
     (advance)
     (print "<parameterList>")
     (cond [(not (equal? line1 ")"))
           (parse-parameterList)])
     (print "</parameterList>")
     (print line)
     (advance)
     (parse-subroutineBody)
     (set! spaces (- spaces 2))
     (print "</subroutineDec>")
     (cond
       [(not (equal? line1 "}"))
        (parse-subroutine)]))


 (define (parse-parameterList)
   (set! spaces (+ spaces 2))
   (print line)
   (advance)
   (print line)
   (advance)
   (let loop()
     (cond
       [(equal? line1 ",")
        (print line)
        (advance)
        (print line)
        (advance)
        (print line)
        (advance)
        (loop)]))
    (set! spaces (- spaces 2)))
   

  (define (parse-subroutineBody)
    (print "<subroutineBody>")
    (set! spaces (+ spaces 2))
    (print line)
    (advance)
    (cond
      [(equal? line1 "var")
       (parse-varDec)])
    (parse-statements)
    (print line)
    (advance)
    (set! spaces (- spaces 2))
    (print "</subroutineBody>"))


  (define (parse-varDec)
    (print "<varDec>")
    (set! spaces (+ spaces 2))
    (print line)
    (advance)
    (print line)
    (advance)
    (print line)
    (advance)
    (let loop()
      (cond ((not (equal? line1 ";"))
          
            (print line)
            (advance)
            (print line)
            (advance)
            (loop))))
    
    (print line)
    (advance)
    (set! spaces (- spaces 2))
    (print "</varDec>")
    (cond [(equal? line1 "var")
           (parse-varDec)]))
  

  (define (parse-statements)
    (print "<statements>")
    (set! spaces (+ spaces 2))
    (let loop()
      (case line1
      (("let") (parse-letStatement) (loop))
      (("if") (parse-ifStatement) (loop))
      (("while") (parse-whileStatement) (loop))
      (("do") (parse-doStatement) (loop))
      (("return") (parse-returnStatement) (loop))))
    (set! spaces (- spaces 2))
    (print "</statements>"))


  (define (parse-letStatement)
    (print "<letStatement>")
    (set! spaces (+ spaces 2))
    (print line)
    (advance)
    (print line)
    (advance)
    (cond [(not (equal? line1 "="))
           (print line)
           (advance)
           (parse-expression)
           (print line)
           (advance)])
    (print line)
    (advance)
    (parse-expression)
    (print line)
    (advance)
    (set! spaces (- spaces 2))
    (print "</letStatement>"))

  
  (define (parse-ifStatement)
    (print "<ifStatement>")
    (set! spaces (+ spaces 2))
    (print line)
    (advance)
    (print line)
    (advance)
    (parse-expression)
    (print line)
    (advance)
    (print line)
    (advance)
    (parse-statements)
    (print line)
    (advance)
    (cond
      [(equal? line1 "else")
       (print line)
       (advance)
       (print line)
       (advance)
       (parse-statements)
       (print line)
       (advance)])
    (set! spaces (- spaces 2))
    (print "</ifStatement>"))

  
  (define (parse-whileStatement)
    (print "<whileStatement>")
    (set! spaces (+ spaces 2))
    (print line)
    (advance)
    (print line)
    (advance)
    (parse-expression)
    (print line)
    (advance)
    (print line)
    (advance)
    (parse-statements)
    (print line)
    (advance)
    (set! spaces (- spaces 2))
    (print "</whileStatement>"))

  
  (define (parse-doStatement)
    (print "<doStatement>")
    (set! spaces (+ spaces 2))
    (print line)
    (advance)
    (parse-subroutineCall line)
    (print line)
    (advance)
    (set! spaces (- spaces 2))
    (print "</doStatement>"))

  
  (define (parse-returnStatement)
    (print "<returnStatement>")
    (set! spaces (+ spaces 2))
    (print line)
    (advance)
    (cond
      [(not (equal? line1 ";"))
       (parse-expression)])
    (print line)
    (advance)
    (set! spaces (- spaces 2))
    (print "</returnStatement>"))


  (define (parse-expression)
    (print "<expression>")
    (set! spaces (+ spaces 2))
    (parse-term)
    (let loop ()
      (cond
        [(or
          (equal? line1 "+")
          (equal? line1 "-")
          (equal? line1 "*")
          (equal? line1 "/")
          (equal? line1 "&amp;")
          (equal? line1 "|")
          (equal? line1 "&lt;")
          (equal? line1 "&gt;")
          (equal? line1 "="))
         (print line)
         (advance)
         (parse-term)
         (loop)]))
    (set! spaces (- spaces 2))
    (print "</expression>"))


  (define (parse-term)
    (print "<term>")
    (set! spaces (+ spaces 2))
    (case line1
      (("-") (print line) (advance) (parse-term))
      (("~") (print line) (advance) (parse-term))
      (("(") (print line) (advance) (parse-expression) (print line) (advance))
      (("true") (print line) (advance))
      (("false") (print line) (advance))
      (("null") (print line) (advance))
      (("this") (print line) (advance)))
    (cond [(or (equal? line0 "integerConstant") (equal? line0 "stringConstant"))
          (print line)
          (advance)]
          [(equal? line0 "identifier")
           (define my-line line)
           (advance)
           (case line1
             (("[")
              (print my-line)
              (print line)
              (advance)
              (parse-expression)
              (print line)
              (advance))
             ((".")
              (parse-subroutineCall my-line))
             (("(")
              (parse-subroutineCall my-line))
             (else (print my-line)))])
    (set! spaces (- spaces 2))
    (print "</term>"))


  (define (parse-subroutineCall my-line)
    (print my-line)
    (cond
      [(equal? my-line line)
       (advance)])
    (cond
      [(equal? line1 ".")
       (print line)
       (advance)
       (print line)
       (advance)])
    (print line)
    (advance)
    (parse-expressionList)
    (print line)
    (advance))


  (define (parse-expressionList)
    (print "<expressionList>")
    (set! spaces (+ spaces 2))
    (cond
      [(not (equal? line1 ")"))
       (parse-expression)
       (let loop ()
       (cond
         [(equal? line1 ",")
          (print line)
          (advance)
          (parse-expression)
          (loop)]))])
    (set! spaces (- spaces 2))
    (print "</expressionList>"))


(parse))
    
