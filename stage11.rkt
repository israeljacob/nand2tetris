#lang racket

(require "binary-tree-class.rkt")
(provide create-vm-output-file)


(define (create-vm-output-file directory xml-file folder-name)
  (define input-port (open-input-file (string-append directory "/" (path->string xml-file))))
  (define vm-file-name (substring (path->string xml-file) 0 (- (string-length (path->string xml-file)) 4)))
  (define output-port (open-output-file (string-append directory "/" vm-file-name ".vm") #:exists 'append))
  (compilling input-port output-port))

(define (count-feilds class-table)
  (define ctr 0)
  (for ((sublist class-table)
        #:when (equal? (third sublist) "field"))
    (set! ctr (+ ctr 1)))
  ctr)

(define (get-list lst1 lst2 str)
  (define (helper lst)
    (cond
      [(empty? lst) #f] ; If the input list is empty, return false
      [(equal? (first (car lst)) str)
       (case (third (car lst))
         (("var") (list-set (car lst) 2 "local"))
         (("field") (list-set (car lst) 2 "this"))
         (("arg") (list-set (car lst) 2 "argument"))
         (else (car lst))
         )] ; If the first element of the current sublist matches the string, return the third element
      [else (helper (rest lst))])) ; Recursively search in the remaining sublists

  (let ([result1 (helper lst1)]
        [result2 (helper lst2)])
    (cond
      [result1 result1] ; If a matching sublist was found in lst1, return its third element
      [else result2])))


(define (compilling input-port output-port)
  
  (define class-name "")
  (define str-spl "")
  (define line (read-line input-port))
  (define line0 "")
  (define line1 "")
  (define class-table '())
  (define method-table '())
  (define static-ctr 0)
  (define field-ctr 0)
  (define arg-ctr 0)
  (define var-ctr 0)
  (define if-ctr 0)
  (define while-ctr 0)
  (define my-list '("" "" "" 0))
  (define size 0)
  (define return-type "")

  (define (advance)
    (set! line (read-line input-port))
    (cond 
      [(equal? line "</class>")]
      [(eof-object? line)]
      [(set! str-spl (string-split line ">"))
       (set! line0 (list-ref (string-split (list-ref (string-split line ">") 0) "<") 1))
       (cond
         [(> (length str-spl) 1)
          (set! line1 (list-ref (string-split (list-ref str-spl 1) "<") 0))
          (set! line1 (substring line1 1 (- (string-length line1) 1)))])]))


  (define (compile-class)
    (set! class-table '())
    (set! static-ctr 0)
    (set! field-ctr 0)
    (advance)
    (advance)
    (set! class-name line1)
    (advance)
    (advance)
    (let loop()
      (cond
        [(equal? line0 "classVarDec")
         (compile-class-var-dec)
         (loop)]))
    (let loop()
      (cond
        [(equal? line0 "subroutineDec")
         (compile-subroutineDec-dec)
         (loop)])))


  (define (compile-class-var-dec)
    (set! my-list '("" "" "" 0))
    (advance)
    (set! my-list (list-set my-list 2 line1))
    (advance)
    (set! my-list (list-set my-list 1 line1))
    (advance)
    (set! my-list (list-set my-list 0 line1))
    (cond ((equal? (list-ref my-list 2) "static")
           (set! my-list (list-set my-list 3 static-ctr))
           (set! static-ctr (+ static-ctr 1)))
          ((equal? (list-ref my-list 2) "field")
           (set! my-list (list-set my-list 3 field-ctr))
           (set! field-ctr (+ field-ctr 1))))
    (set! class-table (append class-table (list my-list)))
    (advance)
    (let loop ()
      (cond [(equal? line1 ",")
             (advance)
             (set! my-list (list-set my-list 0 line1))
             (cond ((equal? (list-ref my-list 2) "static")
                    (set! my-list (list-set my-list 3 static-ctr))
                    (set! static-ctr (+ static-ctr 1)))
                   ((equal? (list-ref my-list 2) "field")
                    (set! my-list (list-set my-list 3 field-ctr))
                    (set! field-ctr (+ field-ctr 1))))
             (set! class-table (append class-table (list my-list)))
             (advance)
             (loop)]))
    (advance)
    (advance))

  (define (compile-subroutineDec-dec)
    (set! method-table '())
    (set! arg-ctr 0)
    (set! var-ctr 0)
    (advance)
    (define func-type line1)
    (advance)
    (set! return-type line1)
    (advance)
    (define func-name line1)
    (advance)
    (advance)
    (compile-parameter-list func-type)
    (advance)
    (compile-subroutine-budy func-type func-name)
    (advance))
    


  (define (compile-parameter-list func-type)
    (set! my-list '("" "" "" 0))
    (cond
      [(equal? func-type "method")
       (set! my-list (list-set my-list 1 class-name))
       (set! my-list (list-set my-list 0 "this"))
       (set! my-list (list-set my-list 2 "arg"))
       (set! my-list (list-set my-list 3 arg-ctr))
       (set! arg-ctr (+ arg-ctr 1))
       (set! method-table (append method-table (list my-list)))])
    (advance)
    (let loop()
      (cond
        [(not (equal? line0 "/parameterList"))
         (set! my-list (list-set my-list 1 line1))
         (advance)
         (set! my-list (list-set my-list 0 line1))
         (advance)
         (set! my-list (list-set my-list 2 "arg"))
         (set! my-list (list-set my-list 3 arg-ctr))
         (set! arg-ctr (+ arg-ctr 1))
         (set! method-table (append method-table (list my-list)))
         (cond [(equal? line1 ",") (advance)])
         (loop)]))
    (advance))

  (define (compile-subroutine-budy func-type func-name)
    (set! if-ctr 0)
    (set! while-ctr 0)
    (advance)
    (advance)
    (compile-var-dec)
    (displayln (string-append "function " class-name "." func-name " " (number->string var-ctr)) output-port)
    (cond
      [(equal? func-type "constructor")
       (let ((size (count-feilds class-table)))
         (displayln (string-append "push constant " (number->string size)) output-port) 
         (displayln "call Memory.alloc 1" output-port)
         (displayln "pop pointer 0" output-port))]
      [(equal? func-type "method")
       (displayln "push argument 0" output-port)
       (displayln "pop pointer 0" output-port) ])
    (compile-statements)
    (advance)
    (advance))


  (define (compile-var-dec)
    (set! my-list '("" "" "" 0))
    (let loop()
      (cond [(equal? line0 "varDec")
             (advance)
             (set! my-list (list-set my-list 2 line1))
             (advance)
             (set! my-list (list-set my-list 1 line1))
             (advance)
             (set! my-list (list-set my-list 0 line1))
             (set! my-list (list-set my-list 3 var-ctr))
             (set! var-ctr (+ var-ctr 1))
             (set! method-table (append method-table (list my-list)))
             (advance)
             (let loop ()
               (cond [(equal? line1 ",")
                      (advance)
                      (set! my-list (list-set my-list 0 line1))
                      (set! my-list (list-set my-list 3 var-ctr))
                      (set! var-ctr (+ var-ctr 1))
                      (set! method-table (append method-table (list my-list)))
                      (advance)
                      (loop)]))
             (advance)
             (advance)
             (loop)])))

  (define (compile-statements)
    (advance)
    (let loop()
      (cond
        [(not (equal? line0 "/statements"))
         (case line0
           (("letStatement") (compile-let-statement))
           (("whileStatement") (compile-while-statement))
           (("ifStatement") (compile-if-statement))
           (("returnStatement") (compile-return-statement))
           (("doStatement") (compile-do-statement)))
         (loop)]))
    (advance))

  (define (compile-let-statement)
    (advance)
    (advance)
    (define name line1)
    (advance)
    (define is-array #f)
    (cond
      [(equal? line1 "[")
       (set! is-array #t)
       (let ((lst (get-list method-table class-table name)))
         (advance)
         (compile-expression)
         (displayln (string-append "push " (third lst) " " (number->string (fourth lst)) ) output-port))
       (advance)
       (displayln "add" output-port)])
    (advance)
    (compile-expression)
    (cond [is-array
           (displayln "pop temp 0" output-port)
           (displayln "pop pointer 1" output-port) 
           (displayln "push temp 0" output-port)
           (displayln "pop that 0" output-port) ]
          [else(let ((lst (get-list method-table class-table name)))
                 (displayln (string-append "pop " (third lst) " " (number->string (fourth lst)) ) output-port))])
    (advance)
    (advance))

  (define (compile-if-statement)
    (define true-label (string-append "IF_TRUE" (number->string if-ctr)))
    (define false-label (string-append "IF_FALSE" (number->string if-ctr)))
    (define end-label (string-append "IF_END" (number->string if-ctr)))
    (set! if-ctr (+ if-ctr 1))
    (advance)
    (advance)
    (advance)
    (compile-expression)
    (advance)
    (displayln (string-append "if-goto " true-label) output-port)
    (displayln (string-append "goto " false-label) output-port) 
    (displayln (string-append "label " true-label) output-port) 
    (advance)
    (compile-statements)
    (advance)
    (cond
      [(equal? line1 "else")
        (displayln (string-append "goto " end-label) output-port) 
       (displayln (string-append "label " false-label) output-port) 
       (advance)
       (advance)
       (compile-statements)
       (advance)
       (displayln (string-append "label " end-label) output-port) ]
      [else
       (displayln (string-append "label " false-label) output-port) ])
    (advance))

  (define (compile-while-statement)
    (define start-label (string-append "WHILE_EXP" (number->string while-ctr)))
    (define end-label (string-append "WHILE_END" (number->string while-ctr)))
    (set! while-ctr (+ while-ctr 1))
    (displayln (string-append "label " start-label) output-port) 
    (advance)
    (advance)
    (advance)
    (compile-expression)
    (advance)
    (displayln "not" output-port)
    (displayln (string-append "if-goto " end-label) output-port) 
    (advance)
    (compile-statements)
    (advance)
    (displayln (string-append "goto " start-label) output-port) 
    (displayln (string-append "label " end-label) output-port) 
    (advance))

  (define (compile-do-statement)
    (advance)
    (advance)
    (let ((name line1))
      (advance)
      (compile-function-call name))
    (advance)
    (advance)
    (cond
      [(equal? line0 "/doStatement")
       (advance)])
    (displayln "pop temp 0" output-port))
  
  (define (compile-return-statement)
    (advance)
    (advance)
    (cond
      [(not (equal? line1 ";"))
       (compile-expression)])
    (cond
      [(equal? return-type "void")
       (displayln "push constant 0" output-port) ])
    (displayln "return" output-port) 
    (advance)
    (advance))

  (define (compile-function-call name)
    (define arg-ctr 0)
    (cond
      [(equal? line1 ".")
       (define lst (get-list method-table class-table name))
       (cond [lst
              (displayln (string-append "push " (third lst) " " (number->string (fourth lst))) output-port)
              (set! name (second lst))
              (set! arg-ctr 1)])
       (advance)
       (set! name (string-append name "." line1))
       (advance)]
      [else
       (displayln "push pointer 0" output-port) 
       (set! name (string-append class-name "." name))
       (set! arg-ctr 1)])
    (advance)
    (set! arg-ctr (+ arg-ctr (compile-argument-list)))
    (advance)
    (displayln (string-append "call " name " " (number->string arg-ctr)) output-port))

  (define (compile-argument-list)
    (define arg-ctr 0)
    (advance)
    (let loop()
      (cond
        [(equal? line0 "expression")
         (compile-expression)
         (set! arg-ctr (+ arg-ctr 1))
         (cond [(equal? line1 ",") (advance)])
         (loop)]))
    arg-ctr)

  (define (compile-expression)
    (advance)
    (compile-term)
    (let loop ()
    (case line1
      (("&amp;") (advance) (compile-term) (displayln "and" output-port) (loop))
      (("|") (advance) (compile-term) (displayln "or" output-port)  (loop))
      (("&gt;") (advance) (compile-term) (displayln "gt" output-port)  (loop))
      (("&lt;") (advance) (compile-term) (displayln "lt" output-port)  (loop))
      (("=") (advance) (compile-term) (displayln "eq" output-port)  (loop))
      (("+") (advance) (compile-term) (displayln "add" output-port)  (loop))
      (("-") (advance) (compile-term) (displayln "sub" output-port)  (loop))
      (("*") (advance) (compile-term) (displayln "call Math.multiply 2" output-port)  (loop))
      (("/") (advance) (compile-term) (displayln "call Math.divide 2" output-port)  (loop))))
    (advance))

  (define (compile-term)
    (advance)
    (cond
      [(or (equal? line0 "integerConstant") (equal? line0 "stringConstant"))
       (case line0
         (("integerConstant") (displayln (string-append "push constant " line1) output-port) (advance))
         (("stringConstant")
          (define length (string-length line1))
          (displayln (string-append "push constant " (number->string length)) output-port)
          (displayln "call String.new 1" output-port)
          (for ([i length])
            (displayln (string-append "push constant " (number->string (char->integer (string-ref line1 i)))) output-port) 
            (displayln "call String.appendChar 2" output-port))
          (advance)))]
      [else(case line1
             (("true") (displayln "push constant 0" output-port) (displayln "not" output-port) (advance))
             (("false") (displayln "push constant 0" output-port)  (advance))
             (("null") (displayln "push constant 0" output-port) (advance))
             (("this") (displayln "push pointer 0" output-port)  (advance))
             (("-") (advance) (compile-term) (displayln "neg" output-port) )
             (("~") (advance) (compile-term) (displayln "not" output-port) )
             (("(") (advance) (compile-expression) (advance))
             (else
              (define name line1)
              (advance)
              (cond
                [(or (equal? line1 ".") (equal? line1 "("))
                 (compile-function-call name)(advance)]
                [else
                 (let ((lst (get-list method-table class-table name)))
                   (cond
                     [(equal? line1 "[")
                      (advance)
                      (compile-expression)
                      (displayln (string-append "push " (third lst) " " (number->string (fourth lst))) output-port)
                      (advance)
                      (displayln "add" output-port)
                      (displayln "pop pointer 1" output-port)
                      (displayln "push that 0" output-port)]
                     [else
                      (displayln (string-append "push " (third lst) " " (number->string (fourth lst))) output-port)]))])))])
    (advance))

  (compile-class)
  (close-input-port input-port)
  (close-output-port output-port))

